{"version":3,"file":"sidebar.d6153dc8ee1466616586.hot-update.js","mappings":";;;;;;;;;;;;;AAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,aAAa,gBAAgB;AAC7H;AACA;AACA;AACA;AACA;AACA,gGAAgG,8BAA8B;AAC9H;AACA;AACA,gGAAgG,8BAA8B;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,uBAAuB,MAAM;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,uBAAuB,KAAK;AAC5B,uBAAuB,KAAK;AAC5B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,8DAA8D,WAAW;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AAC+B;;;;;;;;;;;;;;;;;;;;;;AC59C8B;AAAA,IAExCC,eAAe;EAClC,SAAAA,gBAAA,EAAc;IAAAC,6FAAA,OAAAD,eAAA;IACV,IAAI,CAACE,MAAM,GAAG,IAAIH,+EAAM,CAAC,CAAC;IAC1B,IAAI,CAACI,WAAW,GAAG,KAAK;EAC5B;EAAC,OAAAC,0FAAA,CAAAJ,eAAA;IAAAK,GAAA;IAAAC,KAAA,EAED,SAAAC,cAAcA,CAAA,EAAG;MAAA,IAAAC,KAAA;MACb,IAAI,CAACN,MAAM,CAACO,QAAQ,CAAC,CAAC,CAAC,CAAC;MACxBC,8EAAA,CAAW,YAAM;QACbF,KAAI,CAACN,MAAM,CAACS,UAAU,CAAC;UACnBC,IAAI,EAAE,OAAO;UACbC,UAAU,EAAE,IAAI;UAChBC,MAAM,EAAE,IAAI;UACZC,KAAK,EAAE,IAAI;UACXC,KAAK,EAAE;QACX,CAAC,CAAC,CAACC,IAAI,CAAC,YAAM;UACVC,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;UACzCX,KAAI,CAACL,WAAW,GAAG,IAAI;QAC3B,CAAC,CAAC,SAAM,CAAC,UAAAiB,GAAG,EAAI;UACZF,OAAO,CAACG,KAAK,CAAC,uBAAuB,EAAED,GAAG,CAAC;UAC3CE,KAAK,CAAC,2DAA2D,CAAC;QACtE,CAAC,CAAC;;QAEF;QACAd,KAAI,CAACN,MAAM,CAACqB,4BAA4B,CAAC,UAACC,UAAU,EAAEC,OAAO,EAAK;UAC9D,IAAMC,iBAAiB,GAAGC,QAAQ,CAACC,cAAc,CAAC,gBAAgB,CAAC;UACnEF,iBAAiB,CAACG,WAAW,GAAGJ,OAAO,GACjC,yBAAyB,GAAGD,UAAU,GACtCA,UAAU;QACpB,CAAC,CAAC;MACN,CAAC,EAAE,GAAG,CAAC;IACX;EAAC;IAAAnB,GAAA;IAAAC,KAAA,EAED,SAAAwB,aAAaA,CAAA,EAAG;MACZ,IAAI,CAAC5B,MAAM,CAACO,QAAQ,CAAC,CAAC;MACtBS,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;MAC5C,IAAI,CAAChB,WAAW,GAAG,KAAK;IAC5B;EAAC;IAAAE,GAAA;IAAAC,KAAA,EAED,SAAAyB,eAAeA,CAAA,EAAG;MACd,IAAI,IAAI,CAAC5B,WAAW,EAAE;QAClB,IAAI,CAAC2B,aAAa,CAAC,CAAC;MACxB,CAAC,MAAM;QACH,IAAI,CAACvB,cAAc,CAAC,CAAC;MACzB;IACJ;EAAC;AAAA;;;;;;;;;UC/CH","sources":["webpack://tean-mate/./node_modules/artyom.js/build/artyom.js","webpack://tean-mate/./2-features/STT/ArtyomAssistant.js","webpack://tean-mate/webpack/runtime/getFullHash"],"sourcesContent":["\"use strict\";\r\n/**\r\n * Artyom.js is a voice control, speech recognition and speech synthesis JavaScript library.\r\n *\r\n * @requires {webkitSpeechRecognition && speechSynthesis}\r\n * @license MIT\r\n * @version 1.0.6\r\n * @copyright 2017 Our Code World (www.ourcodeworld.com) All Rights Reserved.\r\n * @author Carlos Delgado (https://github.com/sdkcarlos) and Sema García (https://github.com/semagarcia)\r\n * @see https://sdkcarlos.github.io/sites/artyom.html\r\n * @see http://docs.ourcodeworld.com/projects/artyom-js\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/// <reference path=\"artyom.d.ts\" />\r\n// Remove \"export default \" keywords if willing to build with `npm run artyom-build-window`\r\nvar Artyom = (function () {\r\n    // Triggered at the declaration of \r\n    class Artyom {\r\n        constructor() {\r\n            this.ArtyomCommands = [];\r\n            this.ArtyomVoicesIdentifiers = {\r\n                // German\r\n                \"de-DE\": [\"Google Deutsch\", \"de-DE\", \"de_DE\"],\r\n                // Spanish\r\n                \"es-ES\": [\"Google español\", \"es-ES\", \"es_ES\", \"es-MX\", \"es_MX\"],\r\n                // Italian\r\n                \"it-IT\": [\"Google italiano\", \"it-IT\", \"it_IT\"],\r\n                // Japanese\r\n                \"jp-JP\": [\"Google 日本人\", \"ja-JP\", \"ja_JP\"],\r\n                // English USA\r\n                \"en-US\": [\"Google US English\", \"en-US\", \"en_US\"],\r\n                // English UK\r\n                \"en-GB\": [\"Google UK English Male\", \"Google UK English Female\", \"en-GB\", \"en_GB\"],\r\n                // Brazilian Portuguese\r\n                \"pt-BR\": [\"Google português do Brasil\", \"pt-PT\", \"pt-BR\", \"pt_PT\", \"pt_BR\"],\r\n                // Portugal Portuguese\r\n                // Note: in desktop, there's no voice for portugal Portuguese\r\n                \"pt-PT\": [\"Google português do Brasil\", \"pt-PT\", \"pt_PT\"],\r\n                // Russian\r\n                \"ru-RU\": [\"Google русский\", \"ru-RU\", \"ru_RU\"],\r\n                // Dutch (holland)\r\n                \"nl-NL\": [\"Google Nederlands\", \"nl-NL\", \"nl_NL\"],\r\n                // French\r\n                \"fr-FR\": [\"Google français\", \"fr-FR\", \"fr_FR\"],\r\n                // Polish\r\n                \"pl-PL\": [\"Google polski\", \"pl-PL\", \"pl_PL\"],\r\n                // Indonesian\r\n                \"id-ID\": [\"Google Bahasa Indonesia\", \"id-ID\", \"id_ID\"],\r\n                // Hindi\r\n                \"hi-IN\": [\"Google हिन्दी\", \"hi-IN\", \"hi_IN\"],\r\n                // Mandarin Chinese\r\n                \"zh-CN\": [\"Google 普通话（中国大陆）\", \"zh-CN\", \"zh_CN\"],\r\n                // Cantonese Chinese\r\n                \"zh-HK\": [\"Google 粤語（香港）\", \"zh-HK\", \"zh_HK\"],\r\n                // Native voice\r\n                \"native\": [\"native\"]\r\n            };\r\n            // Important: retrieve the voices of the browser as soon as possible.\r\n            // Normally, the execution of speechSynthesis.getVoices will return at the first time an empty array.\r\n            if (window.hasOwnProperty('speechSynthesis')) {\r\n                speechSynthesis.getVoices();\r\n            }\r\n            else {\r\n                console.error(\"Artyom.js can't speak without the Speech Synthesis API.\");\r\n            }\r\n            // This instance of webkitSpeechRecognition is the one used by Artyom.\r\n            if (window.hasOwnProperty('webkitSpeechRecognition')) {\r\n                this.ArtyomWebkitSpeechRecognition = new window.webkitSpeechRecognition();\r\n            }\r\n            else {\r\n                console.error(\"Artyom.js can't recognize voice without the Speech Recognition API.\");\r\n            }\r\n            this.ArtyomProperties = {\r\n                lang: 'en-GB',\r\n                recognizing: false,\r\n                continuous: false,\r\n                speed: 1,\r\n                volume: 1,\r\n                listen: false,\r\n                mode: \"normal\",\r\n                debug: false,\r\n                helpers: {\r\n                    redirectRecognizedTextOutput: null,\r\n                    remoteProcessorHandler: null,\r\n                    lastSay: null,\r\n                    fatalityPromiseCallback: null\r\n                },\r\n                executionKeyword: null,\r\n                obeyKeyword: null,\r\n                speaking: false,\r\n                obeying: true,\r\n                soundex: false,\r\n                name: null\r\n            };\r\n            this.ArtyomGarbageCollection = [];\r\n            this.ArtyomFlags = {\r\n                restartRecognition: false\r\n            };\r\n            this.ArtyomGlobalEvents = {\r\n                ERROR: \"ERROR\",\r\n                SPEECH_SYNTHESIS_START: \"SPEECH_SYNTHESIS_START\",\r\n                SPEECH_SYNTHESIS_END: \"SPEECH_SYNTHESIS_END\",\r\n                TEXT_RECOGNIZED: \"TEXT_RECOGNIZED\",\r\n                COMMAND_RECOGNITION_START: \"COMMAND_RECOGNITION_START\",\r\n                COMMAND_RECOGNITION_END: \"COMMAND_RECOGNITION_END\",\r\n                COMMAND_MATCHED: \"COMMAND_MATCHED\",\r\n                NOT_COMMAND_MATCHED: \"NOT_COMMAND_MATCHED\"\r\n            };\r\n            this.Device = {\r\n                isMobile: false,\r\n                isChrome: true\r\n            };\r\n            if (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Windows Phone/i)) {\r\n                this.Device.isMobile = true;\r\n            }\r\n            if (navigator.userAgent.indexOf(\"Chrome\") == -1) {\r\n                this.Device.isChrome = false;\r\n            }\r\n            /**\r\n             * The default voice of Artyom in the Desktop. In mobile, you will need to initialize (or force the language)\r\n             * with a language code in order to find an available voice in the device, otherwise it will use the native voice.\r\n             */\r\n            this.ArtyomVoice = {\r\n                default: false,\r\n                lang: \"en-GB\",\r\n                localService: false,\r\n                name: \"Google UK English Male\",\r\n                voiceURI: \"Google UK English Male\"\r\n            };\r\n        }\r\n        /**\r\n             * Add dinamically commands to artyom using\r\n             * You can even add commands while artyom is active.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/addcommands\r\n             * @since 0.6\r\n             * @param {Object | Array[Objects]} param\r\n             * @returns {undefined}\r\n             */\r\n        addCommands(param) {\r\n            var _this = this;\r\n            var processCommand = function (command) {\r\n                if (command.hasOwnProperty(\"indexes\")) {\r\n                    _this.ArtyomCommands.push(command);\r\n                }\r\n                else {\r\n                    console.error(\"The given command doesn't provide any index to execute.\");\r\n                }\r\n            };\r\n            if (param instanceof Array) {\r\n                for (var i = 0; i < param.length; i++) {\r\n                    processCommand(param[i]);\r\n                }\r\n            }\r\n            else {\r\n                processCommand(param);\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n             * The SpeechSynthesisUtterance objects are stored in the artyom_garbage_collector variable\r\n             * to prevent the wrong behaviour of artyom.say.\r\n             * Use this method to clear all spoken SpeechSynthesisUtterance unused objects.\r\n             *\r\n             * @returns {Array<any>}\r\n             */\r\n        clearGarbageCollection() {\r\n            return this.ArtyomGarbageCollection = [];\r\n        }\r\n        /**\r\n             * Displays a message in the console if the artyom propery DEBUG is set to true.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/debug\r\n             * @returns {undefined}\r\n             */\r\n        debug(message, type) {\r\n            var preMessage = \"[v\" + this.getVersion() + \"] Artyom.js\";\r\n            if (this.ArtyomProperties.debug === true) {\r\n                switch (type) {\r\n                    case \"error\":\r\n                        console.log(\"%c\" + preMessage + \":%c \" + message, 'background: #C12127; color: black;', 'color:black;');\r\n                        break;\r\n                    case \"warn\":\r\n                        console.warn(message);\r\n                        break;\r\n                    case \"info\":\r\n                        console.log(\"%c\" + preMessage + \":%c \" + message, 'background: #4285F4; color: #FFFFFF', 'color:black;');\r\n                        break;\r\n                    default:\r\n                        console.log(\"%c\" + preMessage + \":%c \" + message, 'background: #005454; color: #BFF8F8', 'color:black;');\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n             * Artyom have it's own diagnostics.\r\n             * Run this function in order to detect why artyom is not initialized.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/detecterrors\r\n             * @param {type} callback\r\n             * @returns {}\r\n             */\r\n        detectErrors() {\r\n            var _this = this;\r\n            if ((window.location.protocol) == \"file:\") {\r\n                var message = \"Error: running Artyom directly from a file. The APIs require a different communication protocol like HTTP or HTTPS\";\r\n                console.error(message);\r\n                return {\r\n                    code: \"artyom_error_localfile\",\r\n                    message: message\r\n                };\r\n            }\r\n            if (!_this.Device.isChrome) {\r\n                var message = \"Error: the Speech Recognition and Speech Synthesis APIs require the Google Chrome Browser to work.\";\r\n                console.error(message);\r\n                return {\r\n                    code: \"artyom_error_browser_unsupported\",\r\n                    message: message\r\n                };\r\n            }\r\n            if (window.location.protocol != \"https:\") {\r\n                console.warn(\"Warning: artyom is being executed using the '\" + window.location.protocol + \"' protocol. The continuous mode requires a secure protocol (HTTPS)\");\r\n            }\r\n            return false;\r\n        }\r\n        /**\r\n             * Removes all the added commands of artyom.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/emptycommands\r\n             * @since 0.6\r\n             * @returns {Array}\r\n             */\r\n        emptyCommands() {\r\n            return this.ArtyomCommands = [];\r\n        }\r\n        /**\r\n             * Returns an object with data of the matched element\r\n             *\r\n             * @private\r\n             * @param {string} comando\r\n             * @returns {MatchedCommand}\r\n             */\r\n        execute(voz) {\r\n            var _this = this;\r\n            if (!voz) {\r\n                console.warn(\"Internal error: Execution of empty command\");\r\n                return;\r\n            }\r\n            // If artyom was initialized with a name, verify that the name begins with it to allow the execution of commands.\r\n            if (_this.ArtyomProperties.name) {\r\n                if (voz.indexOf(_this.ArtyomProperties.name) != 0) {\r\n                    _this.debug(\"Artyom requires with a name \\\"\" + _this.ArtyomProperties.name + \"\\\" but the name wasn't spoken.\", \"warn\");\r\n                    return;\r\n                }\r\n                // Remove name from voice command\r\n                voz = voz.substr(_this.ArtyomProperties.name.length);\r\n            }\r\n            _this.debug(\">> \" + voz);\r\n            /** @3\r\n             * Artyom needs time to think that\r\n             */\r\n            for (var i = 0; i < _this.ArtyomCommands.length; i++) {\r\n                var instruction = _this.ArtyomCommands[i];\r\n                var opciones = instruction.indexes;\r\n                var encontrado = -1;\r\n                var wildy = \"\";\r\n                for (var c = 0; c < opciones.length; c++) {\r\n                    var opcion = opciones[c];\r\n                    if (!instruction.smart) {\r\n                        continue; //Jump if is not smart command\r\n                    }\r\n                    // Process RegExp\r\n                    if (opcion instanceof RegExp) {\r\n                        // If RegExp matches \r\n                        if (opcion.test(voz)) {\r\n                            _this.debug(\">> REGEX \" + opcion.toString() + \" MATCHED AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                            encontrado = parseInt(c.toString());\r\n                        }\r\n                        // Otherwise just wildcards\r\n                    }\r\n                    else {\r\n                        if (opcion.indexOf(\"*\") != -1) {\r\n                            ///LOGIC HERE\r\n                            var grupo = opcion.split(\"*\");\r\n                            if (grupo.length > 2) {\r\n                                console.warn(\"Artyom found a smart command with \" + (grupo.length - 1) + \" wildcards. Artyom only support 1 wildcard for each command. Sorry\");\r\n                                continue;\r\n                            }\r\n                            //START SMART COMMAND\r\n                            var before = grupo[0];\r\n                            var later = grupo[1];\r\n                            // Wildcard in the end\r\n                            if ((later == \"\") || (later == \" \")) {\r\n                                if ((voz.indexOf(before) != -1) || ((voz.toLowerCase()).indexOf(before.toLowerCase()) != -1)) {\r\n                                    wildy = voz.replace(before, '');\r\n                                    wildy = (wildy.toLowerCase()).replace(before.toLowerCase(), '');\r\n                                    encontrado = parseInt(c.toString());\r\n                                }\r\n                            }\r\n                            else {\r\n                                if ((voz.indexOf(before) != -1) || ((voz.toLowerCase()).indexOf(before.toLowerCase()) != -1)) {\r\n                                    if ((voz.indexOf(later) != -1) || ((voz.toLowerCase()).indexOf(later.toLowerCase()) != -1)) {\r\n                                        wildy = voz.replace(before, '').replace(later, '');\r\n                                        wildy = (wildy.toLowerCase()).replace(before.toLowerCase(), '').replace(later.toLowerCase(), '');\r\n                                        wildy = (wildy.toLowerCase()).replace(later.toLowerCase(), '');\r\n                                        encontrado = parseInt(c.toString());\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            console.warn(\"Founded command marked as SMART but have no wildcard in the indexes, remove the SMART for prevent extensive memory consuming or add the wildcard *\");\r\n                        }\r\n                    }\r\n                    if ((encontrado >= 0)) {\r\n                        encontrado = parseInt(c.toString());\r\n                        break;\r\n                    }\r\n                }\r\n                if (encontrado >= 0) {\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\r\n                    var response = {\r\n                        index: encontrado,\r\n                        instruction: instruction,\r\n                        wildcard: {\r\n                            item: wildy,\r\n                            full: voz\r\n                        }\r\n                    };\r\n                    return response;\r\n                }\r\n            } //End @3\r\n\r\n\r\n\r\n\r\n            /** @1\r\n             * Search for IDENTICAL matches in the commands if nothing matches\r\n             * start with a index match in commands\r\n             */\r\n            for (var i = 0; i < _this.ArtyomCommands.length; i++) {\r\n                var instruction = _this.ArtyomCommands[i];\r\n                var opciones = instruction.indexes;\r\n                var encontrado = -1;\r\n                /**\r\n                 * Execution of match with identical commands\r\n                 */\r\n                for (var c = 0; c < opciones.length; c++) {\r\n                    var opcion = opciones[c];\r\n                    if (instruction.smart) {\r\n                        continue; //Jump wildcard commands\r\n                    }\r\n                    if ((voz === opcion)) {\r\n                        _this.debug(\">> MATCHED FULL EXACT OPTION \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                        encontrado = parseInt(c.toString());\r\n                        break;\r\n                    }\r\n                    else if ((voz.toLowerCase() === opcion.toLowerCase())) {\r\n                        _this.debug(\">> MATCHED OPTION CHANGING ALL TO LOWERCASE \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                        encontrado = parseInt(c.toString());\r\n                        break;\r\n                    }\r\n                }\r\n                if (encontrado >= 0) {\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\r\n                    var response = {\r\n                        index: encontrado,\r\n                        instruction: instruction\r\n                    };\r\n                    return response;\r\n                }\r\n            } //End @1\r\n\r\n\r\n\r\n\r\n\r\n            /**\r\n             * Step 3 Commands recognition.\r\n             * If the command is not smart, and any of the commands match exactly then try to find\r\n             * a command in all the quote.\r\n             */\r\n            for (var i = 0; i < _this.ArtyomCommands.length; i++) {\r\n                var instruction = _this.ArtyomCommands[i];\r\n                var opciones = instruction.indexes;\r\n                var encontrado = -1;\r\n                /**\r\n                 * Execution of match with index\r\n                 */\r\n                for (var c = 0; c < opciones.length; c++) {\r\n                    if (instruction.smart) {\r\n                        continue; //Jump wildcard commands\r\n                    }\r\n                    var opcion = opciones[c];\r\n                    if ((voz.indexOf(opcion) >= 0)) {\r\n                        _this.debug(\">> MATCHED INDEX EXACT OPTION \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                        encontrado = parseInt(c.toString());\r\n                        break;\r\n                    }\r\n                    else if (((voz.toLowerCase()).indexOf(opcion.toLowerCase()) >= 0)) {\r\n                        _this.debug(\">> MATCHED INDEX OPTION CHANGING ALL TO LOWERCASE \" + opcion + \" AGAINST \" + voz + \" WITH INDEX \" + c + \" IN COMMAND \", \"info\");\r\n                        encontrado = parseInt(c.toString());\r\n                        break;\r\n                    }\r\n                }\r\n                if (encontrado >= 0) {\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\r\n                    var response = {\r\n                        index: encontrado,\r\n                        instruction: instruction\r\n                    };\r\n                    return response;\r\n                }\r\n            } //End Step 3\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            /**\r\n             * If the soundex options is enabled, proceed to process the commands in case that any of the previous\r\n             * ways of processing (exact, lowercase and command in quote) didn't match anything.\r\n             * Based on the soundex algorithm match a command if the spoken text is similar to any of the artyom commands.\r\n             * Example :\r\n             * If you have a command with \"Open Wallmart\" and \"Open Willmar\" is recognized, the open wallmart command will be triggered.\r\n             * soundex(\"Open Wallmart\") == soundex(\"Open Willmar\") <= true\r\n             *\r\n             */\r\n            if (_this.ArtyomProperties.soundex) {\r\n                for (var i = 0; i < _this.ArtyomCommands.length; i++) {\r\n                    var instruction = _this.ArtyomCommands[i];\r\n                    var opciones = instruction.indexes;\r\n                    var encontrado = -1;\r\n                    for (var c = 0; c < opciones.length; c++) {\r\n                        var opcion = opciones[c];\r\n                        if (instruction.smart) {\r\n                            continue; //Jump wildcard commands\r\n                        }\r\n                        if (_this.soundex(voz) == _this.soundex(opcion)) {\r\n                            _this.debug(\">> Matched Soundex command '\" + opcion + \"' AGAINST '\" + voz + \"' with index \" + c, \"info\");\r\n                            encontrado = parseInt(c.toString());\r\n                            _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_MATCHED);\r\n                            var response = {\r\n                                index: encontrado,\r\n                                instruction: instruction\r\n                            };\r\n                            return response;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.NOT_COMMAND_MATCHED);\r\n            _this.triggerEvent(_this.ArtyomGlobalEvents.NOT_COMMAND_MATCHED);\r\n            return;\r\n        }\r\n        /**\r\n             * Force artyom to stop listen even if is in continuos mode.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/fatality\r\n             * @returns {Boolean}\r\n             */\r\n        fatality() {\r\n            var _this = this;\r\n            //fatalityPromiseCallback\r\n            return new Promise(function (resolve, reject) {\r\n                // Expose the fatality promise callback to the helpers object of Artyom.\r\n                // The promise isn't resolved here itself but in the onend callback of\r\n                // the speechRecognition instance of artyom\r\n                _this.ArtyomProperties.helpers.fatalityPromiseCallback = resolve;\r\n                try {\r\n                    // If config is continuous mode, deactivate anyway.\r\n                    _this.ArtyomFlags.restartRecognition = false;\r\n                    _this.ArtyomWebkitSpeechRecognition.stop();\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n             * Returns an array with all the available commands for artyom.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getavailablecommands\r\n             * @readonly\r\n             * @returns {Array}\r\n             */\r\n        getAvailableCommands() {\r\n            return this.ArtyomCommands;\r\n        }\r\n        /**\r\n             * Artyom can return inmediately the voices available in your browser.\r\n             *\r\n             * @readonly\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getvoices\r\n             * @returns {Array}\r\n             */\r\n        getVoices() {\r\n            return window.speechSynthesis.getVoices();\r\n        }\r\n        /**\r\n             * Verify if the browser supports speechSynthesis.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/speechsupported\r\n             * @returns {Boolean}\r\n             */\r\n        speechSupported() {\r\n            return 'speechSynthesis' in window;\r\n        }\r\n        /**\r\n             * Verify if the browser supports webkitSpeechRecognition.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/recognizingsupported\r\n             * @returns {Boolean}\r\n             */\r\n        recognizingSupported() {\r\n            return 'webkitSpeechRecognition' in window;\r\n        }\r\n        /**\r\n             * Stops the actual and pendings messages that artyom have to say.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/shutup\r\n             * @returns {undefined}\r\n             */\r\n        shutUp() {\r\n            if ('speechSynthesis' in window) {\r\n                do {\r\n                    window.speechSynthesis.cancel();\r\n                } while (window.speechSynthesis.pending === true);\r\n            }\r\n            this.ArtyomProperties.speaking = false;\r\n            this.clearGarbageCollection();\r\n        }\r\n        /**\r\n             * Returns an object with the actual properties of artyom.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getproperties\r\n             * @returns {object}\r\n             */\r\n        getProperties() {\r\n            return this.ArtyomProperties;\r\n        }\r\n        /**\r\n             * Returns the code language of artyom according to initialize function.\r\n             * if initialize not used returns english GB.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/getlanguage\r\n             * @returns {String}\r\n             */\r\n        getLanguage() {\r\n            return this.ArtyomProperties.lang;\r\n        }\r\n        /**\r\n             * Retrieves the used version of Artyom.js\r\n             *\r\n             * @returns {String}\r\n             */\r\n        getVersion() {\r\n            return '1.0.6';\r\n        }\r\n        /**\r\n             * Artyom awaits for orders when this function\r\n             * is executed.\r\n             *\r\n             * If artyom gets a first parameter the instance will be stopped.\r\n             *\r\n             * @private\r\n             * @returns {undefined}\r\n             */\r\n        hey(resolve, reject) {\r\n            var start_timestamp;\r\n            var artyom_is_allowed;\r\n            var _this = this;\r\n            /**\r\n             * On mobile devices the recognized text is always thrown twice.\r\n             * By setting the following configuration, fixes the issue\r\n             */\r\n            if (this.Device.isMobile) {\r\n                this.ArtyomWebkitSpeechRecognition.continuous = false;\r\n                this.ArtyomWebkitSpeechRecognition.interimResults = false;\r\n                this.ArtyomWebkitSpeechRecognition.maxAlternatives = 1;\r\n            }\r\n            else {\r\n                this.ArtyomWebkitSpeechRecognition.continuous = true;\r\n                this.ArtyomWebkitSpeechRecognition.interimResults = true;\r\n            }\r\n            this.ArtyomWebkitSpeechRecognition.lang = this.ArtyomProperties.lang;\r\n            this.ArtyomWebkitSpeechRecognition.onstart = function () {\r\n                _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.COMMAND_RECOGNITION_START);\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_START);\r\n                _this.ArtyomProperties.recognizing = true;\r\n                artyom_is_allowed = true;\r\n                resolve();\r\n            };\r\n            /**\r\n             * Handle all artyom posible exceptions\r\n             *\r\n             * @param {type} event\r\n             * @returns {undefined}\r\n             */\r\n            this.ArtyomWebkitSpeechRecognition.onerror = function (event) {\r\n                // Reject promise on initialization\r\n                reject(event.error);\r\n                // Dispath error globally (artyom.when)\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\r\n                    code: event.error\r\n                });\r\n                if (event.error == 'audio-capture') {\r\n                    artyom_is_allowed = false;\r\n                }\r\n                if (event.error == 'not-allowed') {\r\n                    artyom_is_allowed = false;\r\n                    if (event.timeStamp - start_timestamp < 100) {\r\n                        _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\r\n                            code: \"info-blocked\",\r\n                            message: \"Artyom needs the permision of the microphone, is blocked.\"\r\n                        });\r\n                    }\r\n                    else {\r\n                        _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\r\n                            code: \"info-denied\",\r\n                            message: \"Artyom needs the permision of the microphone, is denied\"\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             * Check if continuous mode is active and restart the recognition.\r\n             * Throw events too.\r\n             *\r\n             * @returns {undefined}\r\n             */\r\n            _this.ArtyomWebkitSpeechRecognition.onend = function () {\r\n                if (_this.ArtyomFlags.restartRecognition === true) {\r\n                    if (artyom_is_allowed === true) {\r\n                        _this.ArtyomWebkitSpeechRecognition.start();\r\n                        _this.debug(\"Continuous mode enabled, restarting\", \"info\");\r\n                    }\r\n                    else {\r\n                        console.error(\"Verify the microphone and check for the table of errors in sdkcarlos.github.io/sites/artyom.html to solve your problem. If you want to give your user a message when an error appears add an artyom listener\");\r\n                    }\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END, {\r\n                        code: \"continuous_mode_enabled\",\r\n                        message: \"OnEnd event reached with continuous mode\"\r\n                    });\r\n                }\r\n                else {\r\n                    // If the fatality promise callback was set, invoke it\r\n                    if (_this.ArtyomProperties.helpers.fatalityPromiseCallback) {\r\n                        // As the speech recognition doesn't finish really, wait 500ms\r\n                        // to trigger the real fatality callback\r\n                        setTimeout(function () {\r\n                            _this.ArtyomProperties.helpers.fatalityPromiseCallback();\r\n                        }, 500);\r\n                        _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END, {\r\n                            code: \"continuous_mode_disabled\",\r\n                            message: \"OnEnd event reached without continuous mode\"\r\n                        });\r\n                    }\r\n                }\r\n                _this.ArtyomProperties.recognizing = false;\r\n            };\r\n            /**\r\n             * Declare the processor dinamycally according to the mode of artyom\r\n             * to increase the performance.\r\n             *\r\n             * @type {Function}\r\n             * @return\r\n             */\r\n            var onResultProcessor;\r\n            // Process the recognition in normal mode\r\n            if (_this.ArtyomProperties.mode == \"normal\") {\r\n                onResultProcessor = function (event) {\r\n                    if (!_this.ArtyomCommands.length) {\r\n                        _this.debug(\"No commands to process in normal mode.\");\r\n                        return;\r\n                    }\r\n                    var cantidadResultados = event.results.length;\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.TEXT_RECOGNIZED);\r\n                    for (var i = event.resultIndex; i < cantidadResultados; ++i) {\r\n                        var identificated = event.results[i][0].transcript;\r\n                        if (event.results[i].isFinal) {\r\n                            var comando = _this.execute(identificated.trim());\r\n                            // Redirect the output of the text if necessary\r\n                            if (typeof (_this.ArtyomProperties.helpers.redirectRecognizedTextOutput) === \"function\") {\r\n                                _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, true);\r\n                            }\r\n                            if ((comando) && (_this.ArtyomProperties.recognizing == true)) {\r\n                                _this.debug(\"<< Executing Matching Recognition in normal mode >>\", \"info\");\r\n                                _this.ArtyomWebkitSpeechRecognition.stop();\r\n                                _this.ArtyomProperties.recognizing = false;\r\n                                // Execute the command if smart\r\n                                if (comando.wildcard) {\r\n                                    comando.instruction.action(comando.index, comando.wildcard.item, comando.wildcard.full);\r\n                                    // Execute a normal command\r\n                                }\r\n                                else {\r\n                                    comando.instruction.action(comando.index);\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Redirect output when necesary\r\n                            if (typeof (_this.ArtyomProperties.helpers.redirectRecognizedTextOutput) === \"function\") {\r\n                                _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, false);\r\n                            }\r\n                            if (typeof (_this.ArtyomProperties.executionKeyword) === \"string\") {\r\n                                if (identificated.indexOf(_this.ArtyomProperties.executionKeyword) != -1) {\r\n                                    var comando = _this.execute(identificated.replace(_this.ArtyomProperties.executionKeyword, '').trim());\r\n                                    if ((comando) && (_this.ArtyomProperties.recognizing == true)) {\r\n                                        _this.debug(\"<< Executing command ordered by ExecutionKeyword >>\", 'info');\r\n                                        _this.ArtyomWebkitSpeechRecognition.stop();\r\n                                        _this.ArtyomProperties.recognizing = false;\r\n                                        //Executing Command Action\r\n                                        if (comando.wildcard) {\r\n                                            comando.instruction.action(comando.index, comando.wildcard.item, comando.wildcard.full);\r\n                                        }\r\n                                        else {\r\n                                            comando.instruction.action(comando.index);\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            _this.debug(\"Normal mode : \" + identificated);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n            // Process the recognition in quick mode\r\n            if (_this.ArtyomProperties.mode == \"quick\") {\r\n                onResultProcessor = function (event) {\r\n                    if (!_this.ArtyomCommands.length) {\r\n                        _this.debug(\"No commands to process.\");\r\n                        return;\r\n                    }\r\n                    var cantidadResultados = event.results.length;\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.TEXT_RECOGNIZED);\r\n                    for (var i = event.resultIndex; i < cantidadResultados; ++i) {\r\n                        var identificated = event.results[i][0].transcript;\r\n                        if (!event.results[i].isFinal) {\r\n                            var comando = _this.execute(identificated.trim());\r\n                            //Redirect output when necesary\r\n                            if (typeof (_this.ArtyomProperties.helpers.redirectRecognizedTextOutput) === \"function\") {\r\n                                _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, true);\r\n                            }\r\n                            if ((comando) && (_this.ArtyomProperties.recognizing == true)) {\r\n                                _this.debug(\"<< Executing Matching Recognition in quick mode >>\", \"info\");\r\n                                _this.ArtyomWebkitSpeechRecognition.stop();\r\n                                _this.ArtyomProperties.recognizing = false;\r\n                                //Executing Command Action\r\n                                if (comando.wildcard) {\r\n                                    comando.instruction.action(comando.index, comando.wildcard.item);\r\n                                }\r\n                                else {\r\n                                    comando.instruction.action(comando.index);\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                        else {\r\n                            var comando = _this.execute(identificated.trim());\r\n                            //Redirect output when necesary\r\n                            if (typeof (_this.ArtyomProperties.helpers.redirectRecognizedTextOutput) === \"function\") {\r\n                                _this.ArtyomProperties.helpers.redirectRecognizedTextOutput(identificated, false);\r\n                            }\r\n                            if ((comando) && (_this.ArtyomProperties.recognizing == true)) {\r\n                                _this.debug(\"<< Executing Matching Recognition in quick mode >>\", \"info\");\r\n                                _this.ArtyomWebkitSpeechRecognition.stop();\r\n                                _this.ArtyomProperties.recognizing = false;\r\n                                //Executing Command Action\r\n                                if (comando.wildcard) {\r\n                                    comando.instruction.action(comando.index, comando.wildcard.item);\r\n                                }\r\n                                else {\r\n                                    comando.instruction.action(comando.index);\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                        _this.debug(\"Quick mode : \" + identificated);\r\n                    }\r\n                };\r\n            }\r\n            // Process the recognition in remote mode\r\n            if (_this.ArtyomProperties.mode == \"remote\") {\r\n                onResultProcessor = function (event) {\r\n                    var cantidadResultados = event.results.length;\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.TEXT_RECOGNIZED);\r\n                    if (typeof (_this.ArtyomProperties.helpers.remoteProcessorHandler) !== \"function\") {\r\n                        return _this.debug(\"The remoteProcessorService is undefined.\", \"warn\");\r\n                    }\r\n                    for (var i = event.resultIndex; i < cantidadResultados; ++i) {\r\n                        var identificated = event.results[i][0].transcript;\r\n                        _this.ArtyomProperties.helpers.remoteProcessorHandler({\r\n                            text: identificated,\r\n                            isFinal: event.results[i].isFinal\r\n                        });\r\n                    }\r\n                };\r\n            }\r\n            /**\r\n             * Process the recognition event with the previously\r\n             * declared processor function.\r\n             *\r\n             * @param {type} event\r\n             * @returns {undefined}\r\n             */\r\n            _this.ArtyomWebkitSpeechRecognition.onresult = function (event) {\r\n                if (_this.ArtyomProperties.obeying) {\r\n                    onResultProcessor(event);\r\n                }\r\n                else {\r\n                    // Handle obeyKeyword if exists and artyom is not obeying\r\n                    if (!_this.ArtyomProperties.obeyKeyword) {\r\n                        return;\r\n                    }\r\n                    var temporal = \"\";\r\n                    var interim = \"\";\r\n                    for (var i = 0; i < event.results.length; ++i) {\r\n                        if (event.results[i].isFinal) {\r\n                            temporal += event.results[i][0].transcript;\r\n                        }\r\n                        else {\r\n                            interim += event.results[i][0].transcript;\r\n                        }\r\n                    }\r\n                    _this.debug(\"Artyom is not obeying\", \"warn\");\r\n                    // If the obeyKeyword is found in the recognized text\r\n                    // enable command recognition again\r\n                    if (((interim).indexOf(_this.ArtyomProperties.obeyKeyword) > -1) || (temporal).indexOf(_this.ArtyomProperties.obeyKeyword) > -1) {\r\n                        _this.ArtyomProperties.obeying = true;\r\n                    }\r\n                }\r\n            };\r\n            if (_this.ArtyomProperties.recognizing) {\r\n                _this.ArtyomWebkitSpeechRecognition.stop();\r\n                _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END);\r\n                _this.triggerEvent(_this.ArtyomGlobalEvents.COMMAND_RECOGNITION_END);\r\n            }\r\n            else {\r\n                try {\r\n                    _this.ArtyomWebkitSpeechRecognition.start();\r\n                }\r\n                catch (e) {\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.ERROR, {\r\n                        code: \"recognition_overlap\",\r\n                        message: \"A webkitSpeechRecognition instance has been started while there's already running. Is recommendable to restart the Browser\"\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        /**\r\n             * Set up artyom for the application.\r\n             *\r\n             * This function will set the default language used by artyom\r\n             * or notice the user if artyom is not supported in the actual\r\n             * browser\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/initialize\r\n             * @param {Object} config\r\n             * @returns {Boolean}\r\n             */\r\n        initialize(config) {\r\n            var _this = this;\r\n            if (typeof (config) !== \"object\") {\r\n                return Promise.reject(\"You must give the configuration for start artyom properly.\");\r\n            }\r\n            if (config.hasOwnProperty(\"lang\")) {\r\n                _this.ArtyomVoice = _this.getVoice(config.lang);\r\n                _this.ArtyomProperties.lang = config.lang;\r\n            }\r\n            if (config.hasOwnProperty(\"continuous\")) {\r\n                if (config.continuous) {\r\n                    this.ArtyomProperties.continuous = true;\r\n                    this.ArtyomFlags.restartRecognition = true;\r\n                }\r\n                else {\r\n                    this.ArtyomProperties.continuous = false;\r\n                    this.ArtyomFlags.restartRecognition = false;\r\n                }\r\n            }\r\n            if (config.hasOwnProperty(\"speed\")) {\r\n                this.ArtyomProperties.speed = config.speed;\r\n            }\r\n            if (config.hasOwnProperty(\"soundex\")) {\r\n                this.ArtyomProperties.soundex = config.soundex;\r\n            }\r\n            if (config.hasOwnProperty(\"executionKeyword\")) {\r\n                this.ArtyomProperties.executionKeyword = config.executionKeyword;\r\n            }\r\n            if (config.hasOwnProperty(\"obeyKeyword\")) {\r\n                this.ArtyomProperties.obeyKeyword = config.obeyKeyword;\r\n            }\r\n            if (config.hasOwnProperty(\"volume\")) {\r\n                this.ArtyomProperties.volume = config.volume;\r\n            }\r\n            if (config.hasOwnProperty(\"listen\")) {\r\n                this.ArtyomProperties.listen = config.listen;\r\n            }\r\n            if (config.hasOwnProperty(\"name\")) {\r\n                this.ArtyomProperties.name = config.name;\r\n            }\r\n            if (config.hasOwnProperty(\"debug\")) {\r\n                this.ArtyomProperties.debug = config.debug;\r\n            }\r\n            else {\r\n                console.warn(\"The initialization doesn't provide how the debug mode should be handled. Is recommendable to set this value either to true or false.\");\r\n            }\r\n            if (config.mode) {\r\n                this.ArtyomProperties.mode = config.mode;\r\n            }\r\n            if (this.ArtyomProperties.listen === true) {\r\n                return new Promise(function (resolve, reject) {\r\n                    _this.hey(resolve, reject);\r\n                });\r\n            }\r\n            return Promise.resolve(true);\r\n        }\r\n        /**\r\n             * Add commands like an artisan. If you use artyom for simple tasks\r\n             * then probably you don't like to write a lot to achieve it.\r\n             *\r\n             * Use the artisan syntax to write less, but with the same accuracy.\r\n             *\r\n             * @disclaimer Not a promise-based implementation, just syntax.\r\n             * @returns {Boolean}\r\n             */\r\n        on(indexes, smart) {\r\n            var _this = this;\r\n            return {\r\n                then: function (action) {\r\n                    var command = {\r\n                        indexes: indexes,\r\n                        action: action\r\n                    };\r\n                    if (smart) {\r\n                        command.smart = true;\r\n                    }\r\n                    _this.addCommands(command);\r\n                }\r\n            };\r\n        }\r\n        /**\r\n             * Generates an artyom event with the designed name\r\n             *\r\n             * @param {type} name\r\n             * @returns {undefined}\r\n             */\r\n        triggerEvent(name, param) {\r\n            var event = new CustomEvent(name, {\r\n                'detail': param\r\n            });\r\n            document.dispatchEvent(event);\r\n            return event;\r\n        }\r\n        /**\r\n             * Repeats the last sentence that artyom said.\r\n             * Useful in noisy environments.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/repeatlastsay\r\n             * @param {Boolean} returnObject If set to true, an object with the text and the timestamp when was executed will be returned.\r\n             * @returns {Object}\r\n             */\r\n        repeatLastSay(returnObject) {\r\n            var last = this.ArtyomProperties.helpers.lastSay;\r\n            if (returnObject) {\r\n                return last;\r\n            }\r\n            else {\r\n                if (last != null) {\r\n                    this.say(last.text);\r\n                }\r\n            }\r\n        }\r\n        /**\r\n             * Create a listener when an artyom action is called.\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/when\r\n             * @param {type} event\r\n             * @param {type} action\r\n             * @returns {undefined}\r\n             */\r\n        when(event, action) {\r\n            return document.addEventListener(event, function (e) {\r\n                action(e[\"detail\"]);\r\n            }, false);\r\n        }\r\n        /**\r\n             * Process the recognized text if artyom is active in remote mode.\r\n             *\r\n             * @returns {Boolean}\r\n             */\r\n        remoteProcessorService(action) {\r\n            this.ArtyomProperties.helpers.remoteProcessorHandler = action;\r\n            return true;\r\n        }\r\n        /**\r\n             * Verify if there's a voice available for a language using its language code identifier.\r\n             *\r\n             * @return {Boolean}\r\n             */\r\n        voiceAvailable(languageCode) {\r\n            return typeof (this.getVoice(languageCode)) !== \"undefined\";\r\n        }\r\n        /**\r\n             * A boolean to check if artyom is obeying commands or not.\r\n             *\r\n             * @returns {Boolean}\r\n             */\r\n        isObeying() {\r\n            return this.ArtyomProperties.obeying;\r\n        }\r\n        /**\r\n             * Allow artyom to obey commands again.\r\n             *\r\n             * @returns {Boolean}\r\n             */\r\n        obey() {\r\n            return this.ArtyomProperties.obeying = true;\r\n        }\r\n        /**\r\n             * Pause the processing of commands. Artyom still listening in the background and it can be resumed after a couple of seconds.\r\n             *\r\n             * @returns {Boolean}\r\n             */\r\n        dontObey() {\r\n            return this.ArtyomProperties.obeying = false;\r\n        }\r\n        /**\r\n             * This function returns a boolean according to the speechSynthesis status\r\n             * if artyom is speaking, will return true.\r\n             *\r\n             * Note: This is not a feature of speechSynthesis, therefore this value hangs on\r\n             * the fiability of the onStart and onEnd events of the speechSynthesis\r\n             *\r\n             * @since 0.9.3\r\n             * @summary Returns true if speechSynthesis is active\r\n             * @returns {Boolean}\r\n             */\r\n        isSpeaking() {\r\n            return this.ArtyomProperties.speaking;\r\n        }\r\n        /**\r\n             * This function returns a boolean according to the SpeechRecognition status\r\n             * if artyom is listening, will return true.\r\n             *\r\n             * Note: This is not a feature of SpeechRecognition, therefore this value hangs on\r\n             * the fiability of the onStart and onEnd events of the SpeechRecognition\r\n             *\r\n             * @since 0.9.3\r\n             * @summary Returns true if SpeechRecognition is active\r\n             * @returns {Boolean}\r\n             */\r\n        isRecognizing() {\r\n            return this.ArtyomProperties.recognizing;\r\n        }\r\n        /**\r\n             * This function will return the webkitSpeechRecognition object used by artyom\r\n             * retrieve it only to debug on it or get some values, do not make changes directly\r\n             *\r\n             * @readonly\r\n             * @since 0.9.2\r\n             * @summary Retrieve the native webkitSpeechRecognition object\r\n             * @returns {Object webkitSpeechRecognition}\r\n             */\r\n        getNativeApi() {\r\n            return this.ArtyomWebkitSpeechRecognition;\r\n        }\r\n        /**\r\n             * Returns the SpeechSynthesisUtterance garbageobjects.\r\n             *\r\n             * @returns {Array}\r\n             */\r\n        getGarbageCollection() {\r\n            return this.ArtyomGarbageCollection;\r\n        }\r\n        /**\r\n             *  Retrieve a single voice of the browser by it's language code.\r\n             *  It will return the first voice available for the language on every device.\r\n             *\r\n             * @param languageCode\r\n             */\r\n        getVoice(languageCode) {\r\n            var voiceIdentifiersArray = this.ArtyomVoicesIdentifiers[languageCode];\r\n            if (!voiceIdentifiersArray) {\r\n                console.warn(\"The providen language \" + languageCode + \" isn't available, using English Great britain as default\");\r\n                voiceIdentifiersArray = this.ArtyomVoicesIdentifiers[\"en-GB\"];\r\n            }\r\n            var voice = undefined;\r\n            var voices = speechSynthesis.getVoices();\r\n            var voicesLength = voiceIdentifiersArray.length;\r\n            var _loop_1 = function (i) {\r\n                var foundVoice = voices.filter(function (voice) {\r\n                    return ((voice.name == voiceIdentifiersArray[i]) || (voice.lang == voiceIdentifiersArray[i]));\r\n                })[0];\r\n                if (foundVoice) {\r\n                    voice = foundVoice;\r\n                    return \"break\";\r\n                }\r\n            };\r\n            for (var i = 0; i < voicesLength; i++) {\r\n                var state_1 = _loop_1(i);\r\n                if (state_1 === \"break\")\r\n                    break;\r\n            }\r\n            return voice;\r\n        }\r\n        /**\r\n             * Artyom provide an easy way to create a\r\n             * dictation for your user.\r\n             *\r\n             * Just create an instance and start and stop when you want\r\n             *\r\n             * @returns Object | newDictation\r\n             */\r\n        newDictation(settings) {\r\n            var _this = this;\r\n            if (!_this.recognizingSupported()) {\r\n                console.error(\"SpeechRecognition is not supported in this browser\");\r\n                return false;\r\n            }\r\n            var dictado = new window.webkitSpeechRecognition();\r\n            dictado.continuous = true;\r\n            dictado.interimResults = true;\r\n            dictado.lang = _this.ArtyomProperties.lang;\r\n            dictado.onresult = function (event) {\r\n                var temporal = \"\";\r\n                var interim = \"\";\r\n                for (var i = 0; i < event.results.length; ++i) {\r\n                    if (event.results[i].isFinal) {\r\n                        temporal += event.results[i][0].transcript;\r\n                    }\r\n                    else {\r\n                        interim += event.results[i][0].transcript;\r\n                    }\r\n                }\r\n                if (settings.onResult) {\r\n                    settings.onResult(interim, temporal);\r\n                }\r\n            };\r\n            return new function () {\r\n                var dictation = dictado;\r\n                var flagStartCallback = true;\r\n                var flagRestart = false;\r\n                this.onError = null;\r\n                this.start = function () {\r\n                    if (settings.continuous === true) {\r\n                        flagRestart = true;\r\n                    }\r\n                    dictation.onstart = function () {\r\n                        if (typeof (settings.onStart) === \"function\") {\r\n                            if (flagStartCallback === true) {\r\n                                settings.onStart();\r\n                            }\r\n                        }\r\n                    };\r\n                    dictation.onend = function () {\r\n                        if (flagRestart === true) {\r\n                            flagStartCallback = false;\r\n                            dictation.start();\r\n                        }\r\n                        else {\r\n                            flagStartCallback = true;\r\n                            if (typeof (settings.onEnd) === \"function\") {\r\n                                settings.onEnd();\r\n                            }\r\n                        }\r\n                    };\r\n                    dictation.start();\r\n                };\r\n                this.stop = function () {\r\n                    flagRestart = false;\r\n                    dictation.stop();\r\n                };\r\n                if (typeof (settings.onError) === \"function\") {\r\n                    dictation.onerror = settings.onError;\r\n                }\r\n            };\r\n        }\r\n        /**\r\n             * A voice prompt will be executed.\r\n             *\r\n             * @param {type} config\r\n             * @returns {undefined}\r\n             */\r\n        newPrompt(config) {\r\n            if (typeof (config) !== \"object\") {\r\n                console.error(\"Expected the prompt configuration.\");\r\n            }\r\n            var copyActualCommands = Object.assign([], this.ArtyomCommands);\r\n            var _this = this;\r\n            this.emptyCommands();\r\n            var promptCommand = {\r\n                description: \"Setting the artyom commands only for the prompt. The commands will be restored after the prompt finishes\",\r\n                indexes: config.options,\r\n                action: function (i, wildcard) {\r\n                    _this.ArtyomCommands = copyActualCommands;\r\n                    var toExe = config.onMatch(i, wildcard);\r\n                    if (typeof (toExe) !== \"function\") {\r\n                        console.error(\"onMatch function expects a returning function to be executed\");\r\n                        return;\r\n                    }\r\n                    toExe();\r\n                }\r\n            };\r\n            if (config.smart) {\r\n                promptCommand.smart = true;\r\n            }\r\n            this.addCommands(promptCommand);\r\n            if (typeof (config.beforePrompt) !== \"undefined\") {\r\n                config.beforePrompt();\r\n            }\r\n            var callbacks = {\r\n                onStart: function () {\r\n                    if (typeof (config.onStartPrompt) !== \"undefined\") {\r\n                        config.onStartPrompt();\r\n                    }\r\n                },\r\n                onEnd: function () {\r\n                    if (typeof (config.onEndPrompt) !== \"undefined\") {\r\n                        config.onEndPrompt();\r\n                    }\r\n                }\r\n            };\r\n            this.say(config.question, callbacks);\r\n        }\r\n        /**\r\n             * Says a random quote and returns it's object\r\n             *\r\n             * @param {type} data\r\n             * @returns {object}\r\n             */\r\n        sayRandom(data) {\r\n            if (data instanceof Array) {\r\n                var index = Math.floor(Math.random() * data.length);\r\n                this.say(data[index]);\r\n                return {\r\n                    text: data[index],\r\n                    index: index\r\n                };\r\n            }\r\n            else {\r\n                console.error(\"Random quotes must be in an array !\");\r\n                return null;\r\n            }\r\n        }\r\n        /**\r\n             * Shortcut method to enable the artyom debug on the fly.\r\n             *\r\n             * @returns {Array}\r\n             */\r\n        setDebug(status) {\r\n            if (status) {\r\n                return this.ArtyomProperties.debug = true;\r\n            }\r\n            else {\r\n                return this.ArtyomProperties.debug = false;\r\n            }\r\n        }\r\n        /**\r\n             * Simulate a voice command via JS\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/simulateinstruction\r\n             * @param {type} sentence\r\n             * @returns {undefined}\r\n             */\r\n        simulateInstruction(sentence) {\r\n            var _this = this;\r\n            if ((!sentence) || (typeof (sentence) !== \"string\")) {\r\n                console.warn(\"Cannot execute a non string command\");\r\n                return false;\r\n            }\r\n            var foundCommand = _this.execute(sentence); //Command founded object\r\n            if (typeof (foundCommand) === \"object\") {\r\n                if (foundCommand.instruction) {\r\n                    if (foundCommand.instruction.smart) {\r\n                        _this.debug('Smart command matches with simulation, executing', \"info\");\r\n                        foundCommand.instruction.action(foundCommand.index, foundCommand.wildcard.item, foundCommand.wildcard.full);\r\n                    }\r\n                    else {\r\n                        _this.debug('Command matches with simulation, executing', \"info\");\r\n                        foundCommand.instruction.action(foundCommand.index); //Execute Normal command\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                console.warn(\"No command founded trying with \" + sentence);\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n             * Javascript implementation of the soundex algorithm.\r\n             * @see https://gist.github.com/shawndumas/1262659\r\n             * @returns {String}\r\n             */\r\n        soundex(s) {\r\n            var a = s.toLowerCase().split('');\r\n            var f = a.shift();\r\n            var r = '';\r\n            var codes = { a: \"\", e: \"\", i: \"\", o: \"\", u: \"\", b: 1, f: 1, p: 1, v: 1, c: 2, g: 2, j: 2, k: 2, q: 2, s: 2, x: 2, z: 2, d: 3, t: 3, l: 4, m: 5, n: 5, r: 6 };\r\n            r = f + a\r\n                .map(function (v, i, a) {\r\n                    return codes[v];\r\n                })\r\n                .filter(function (v, i, a) {\r\n                    return ((i === 0) ? v !== codes[f] : v !== a[i - 1]);\r\n                })\r\n                .join('');\r\n            return (r + '000').slice(0, 4).toUpperCase();\r\n        }\r\n        /**\r\n             * Splits a string into an array of strings with a limited size (chunk_length).\r\n             *\r\n             * @param {String} input text to split into chunks\r\n             * @param {Integer} chunk_length limit of characters in every chunk\r\n             */\r\n        splitStringByChunks(input, chunk_length) {\r\n            input = input || \"\";\r\n            chunk_length = chunk_length || 100;\r\n            var curr = chunk_length;\r\n            var prev = 0;\r\n            var output = [];\r\n            while (input[curr]) {\r\n                if (input[curr++] == ' ') {\r\n                    output.push(input.substring(prev, curr));\r\n                    prev = curr;\r\n                    curr += chunk_length;\r\n                }\r\n            }\r\n            output.push(input.substr(prev));\r\n            return output;\r\n        }\r\n        /**\r\n             * Allows to retrieve the recognized spoken text of artyom\r\n             * and do something with it everytime something is recognized\r\n             *\r\n             * @param {String} action\r\n             * @returns {Boolean}\r\n             */\r\n        redirectRecognizedTextOutput(action) {\r\n            if (typeof (action) != \"function\") {\r\n                console.warn(\"Expected function to handle the recognized text ...\");\r\n                return false;\r\n            }\r\n            this.ArtyomProperties.helpers.redirectRecognizedTextOutput = action;\r\n            return true;\r\n        }\r\n        /**\r\n             * Restarts artyom with the initial configuration.\r\n             *\r\n             * @param configuration\r\n             */\r\n        restart() {\r\n            var _this = this;\r\n            var _copyInit = _this.ArtyomProperties;\r\n            return new Promise(function (resolve, reject) {\r\n                _this.fatality().then(function () {\r\n                    _this.initialize(_copyInit).then(resolve, reject);\r\n                });\r\n            });\r\n        }\r\n        /**\r\n             * Talks a text according to the given parameters.\r\n             *\r\n             * @private This function is only to be used internally.\r\n             * @param {String} text Text to be spoken\r\n             * @param {Int} actualChunk Number of chunk of the\r\n             * @param {Int} totalChunks\r\n             * @returns {undefined}\r\n             */\r\n        talk(text, actualChunk, totalChunks, callbacks) {\r\n            var _this = this;\r\n            var msg = new SpeechSynthesisUtterance();\r\n            msg.text = text;\r\n            msg.volume = this.ArtyomProperties.volume;\r\n            msg.rate = this.ArtyomProperties.speed;\r\n            // Select the voice according to the selected\r\n            var availableVoice = _this.getVoice(_this.ArtyomProperties.lang);\r\n            if (callbacks) {\r\n                // If the language to speak has been forced, use it\r\n                if (callbacks.hasOwnProperty(\"lang\")) {\r\n                    availableVoice = _this.getVoice(callbacks.lang);\r\n                }\r\n            }\r\n            // If is a mobile device, provide only the language code in the lang property i.e \"es_ES\"\r\n            if (this.Device.isMobile) {\r\n                // Try to set the voice only if exists, otherwise don't use anything to use the native voice\r\n                if (availableVoice) {\r\n                    msg.lang = availableVoice.lang;\r\n                }\r\n                // If browser provide the entire object\r\n            }\r\n            else {\r\n                msg.voice = availableVoice;\r\n            }\r\n            // If is first text chunk (onStart)\r\n            if (actualChunk == 1) {\r\n                msg.addEventListener('start', function () {\r\n                    // Set artyom is talking\r\n                    _this.ArtyomProperties.speaking = true;\r\n                    // Trigger the onSpeechSynthesisStart event\r\n                    _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_START);\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_START);\r\n                    // Trigger the onStart callback if exists\r\n                    if (callbacks) {\r\n                        if (typeof (callbacks.onStart) == \"function\") {\r\n                            callbacks.onStart.call(msg);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            // If is final text chunk (onEnd)\r\n            if ((actualChunk) >= totalChunks) {\r\n                msg.addEventListener('end', function () {\r\n                    // Set artyom is talking\r\n                    _this.ArtyomProperties.speaking = false;\r\n                    // Trigger the onSpeechSynthesisEnd event\r\n                    _this.debug(\"Event reached : \" + _this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_END);\r\n                    _this.triggerEvent(_this.ArtyomGlobalEvents.SPEECH_SYNTHESIS_END);\r\n                    // Trigger the onEnd callback if exists.\r\n                    if (callbacks) {\r\n                        if (typeof (callbacks.onEnd) == \"function\") {\r\n                            callbacks.onEnd.call(msg);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            // Notice how many chunks were processed for the given text.\r\n            this.debug((actualChunk) + \" text chunk processed succesfully out of \" + totalChunks);\r\n            // Important : Save the SpeechSynthesisUtterance object in memory, otherwise it will get lost\r\n            this.ArtyomGarbageCollection.push(msg);\r\n            window.speechSynthesis.speak(msg);\r\n        }\r\n        /**\r\n             * Process the given text into chunks and execute the private function talk\r\n             *\r\n             * @tutorial http://docs.ourcodeworld.com/projects/artyom-js/documentation/methods/say\r\n             * @param {String} message Text to be spoken\r\n             * @param {Object} callbacks\r\n             * @returns {undefined}\r\n             */\r\n        say(message, callbacks) {\r\n            var artyom_say_max_chunk_length = 115;\r\n            var _this = this;\r\n            var definitive = [];\r\n            if (this.speechSupported()) {\r\n                if (typeof (message) != 'string') {\r\n                    return console.warn(\"Artyom expects a string to speak \" + typeof message + \" given\");\r\n                }\r\n                if (!message.length) {\r\n                    return console.warn(\"Cannot speak empty string\");\r\n                }\r\n                // If the providen text is long, proceed to split it\r\n                if (message.length > artyom_say_max_chunk_length) {\r\n                    // Split the given text by pause reading characters [\",\",\":\",\";\",\". \"] to provide a natural reading feeling.\r\n                    var naturalReading = message.split(/,|:|\\. |;/);\r\n                    naturalReading.forEach(function (chunk, index) {\r\n                        // If the sentence is too long and could block the API, split it to prevent any errors.\r\n                        if (chunk.length > artyom_say_max_chunk_length) {\r\n                            // Process the providen string into strings (withing an array) of maximum aprox. 115 characters to prevent any error with the API.\r\n                            var temp_processed = _this.splitStringByChunks(chunk, artyom_say_max_chunk_length);\r\n                            // Add items of the processed sentence into the definitive chunk.\r\n                            definitive.push.apply(definitive, temp_processed);\r\n                        }\r\n                        else {\r\n                            // Otherwise just add the sentence to being spoken.\r\n                            definitive.push(chunk);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    definitive.push(message);\r\n                }\r\n                // Clean any empty item in array\r\n                definitive = definitive.filter(function (e) { return e; });\r\n                // Finally proceed to talk the chunks and assign the callbacks.\r\n                definitive.forEach(function (chunk, index) {\r\n                    var numberOfChunk = (index + 1);\r\n                    if (chunk) {\r\n                        _this.talk(chunk, numberOfChunk, definitive.length, callbacks);\r\n                    }\r\n                });\r\n                // Save the spoken text into the lastSay object of artyom\r\n                _this.ArtyomProperties.helpers.lastSay = {\r\n                    text: message,\r\n                    date: new Date()\r\n                };\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    ;\r\n    return Artyom;\r\n}());\r\nconst _default = Artyom;\r\nexport { _default as default };\r\n","import Artyom from '/node_modules/artyom.js/build/artyom.js';\n\nexport default class ArtyomAssistant {\n  constructor() {\n      this.artyom = new Artyom();\n      this.isListening = false;\n  }\n\n  startListening() {\n      this.artyom.fatality(); // Reset Artyom\n      setTimeout(() => {\n          this.artyom.initialize({\n              lang: \"en_US\",\n              continuous: true,\n              listen: true,\n              debug: true,\n              speed: 1,\n          }).then(() => {\n              console.log(\"Artyom is ready to listen!\");\n              this.isListening = true;\n          }).catch(err => {\n              console.error(\"Initialization error:\", err);\n              alert(\"Artyom initialization failed. Please check your settings.\");\n          });\n\n          // Redirect recognized text output to sidebar\n          this.artyom.redirectRecognizedTextOutput((recognized, isFinal) => {\n              const recognizedTextDiv = document.getElementById(\"recognizedText\");\n              recognizedTextDiv.textContent = isFinal\n                  ? \"Final recognized text: \" + recognized\n                  : recognized;\n          });\n      }, 250);\n  }\n\n  stopListening() {\n      this.artyom.fatality();\n      console.log(\"Artyom has stopped listening.\");\n      this.isListening = false;\n  }\n\n  toggleListening() {\n      if (this.isListening) {\n          this.stopListening();\n      } else {\n          this.startListening();\n      }\n  }\n}","__webpack_require__.h = () => (\"ee9e8c9ed27f81c4dc61\")"],"names":["Artyom","ArtyomAssistant","_classCallCheck","artyom","isListening","_createClass","key","value","startListening","_this","fatality","_setTimeout","initialize","lang","continuous","listen","debug","speed","then","console","log","err","error","alert","redirectRecognizedTextOutput","recognized","isFinal","recognizedTextDiv","document","getElementById","textContent","stopListening","toggleListening","default"],"sourceRoot":""}